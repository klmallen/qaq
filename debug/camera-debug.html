<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QAQ Engine Camera Debug</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #debug-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            min-width: 300px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .debug-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }
        
        .debug-section:last-child {
            border-bottom: none;
        }
        
        .debug-title {
            color: #4CAF50;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .debug-info {
            font-size: 12px;
            line-height: 1.4;
            color: #ccc;
        }
        
        .debug-button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 6px 12px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        
        .debug-button:hover {
            background: #1976D2;
        }
        
        .debug-button.danger {
            background: #f44336;
        }
        
        .debug-button.danger:hover {
            background: #d32f2f;
        }
        
        .debug-log {
            background: #000;
            color: #0f0;
            padding: 10px;
            border-radius: 4px;
            font-size: 11px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
            margin-top: 10px;
        }
        
        .controls-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #333;
            font-size: 12px;
        }
        
        .controls-info h4 {
            margin: 0 0 8px 0;
            color: #4CAF50;
        }
        
        .controls-info ul {
            margin: 0;
            padding-left: 15px;
        }
        
        .controls-info li {
            margin-bottom: 3px;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="debug-panel">
            <div class="debug-section">
                <div class="debug-title">🎥 Camera System Debug</div>
                <div class="debug-info" id="camera-info">
                    Initializing...
                </div>
                <div>
                    <button class="debug-button" onclick="testCameraPosition()">Test Position</button>
                    <button class="debug-button" onclick="testCameraActivation()">Test Activation</button>
                    <button class="debug-button" onclick="toggleOrbitControls()">Toggle Orbit</button>
                </div>
            </div>
            
            <div class="debug-section">
                <div class="debug-title">🎮 Orbit Controller</div>
                <div class="debug-info" id="orbit-info">
                    Not initialized
                </div>
                <div>
                    <button class="debug-button" onclick="configureOrbitController()">Configure</button>
                    <button class="debug-button" onclick="resetCameraView()">Reset View</button>
                </div>
            </div>
            
            <div class="debug-section">
                <div class="debug-title">🔧 Engine Status</div>
                <div class="debug-info" id="engine-info">
                    Checking...
                </div>
                <div>
                    <button class="debug-button" onclick="checkEngineStatus()">Refresh Status</button>
                    <button class="debug-button danger" onclick="clearLog()">Clear Log</button>
                </div>
            </div>
            
            <div class="debug-log" id="debug-log"></div>
        </div>
        
        <div class="controls-info">
            <h4>🎮 Controls</h4>
            <ul>
                <li><strong>Left Mouse:</strong> Rotate camera</li>
                <li><strong>Right Mouse:</strong> Pan view</li>
                <li><strong>Mouse Wheel:</strong> Zoom in/out</li>
                <li><strong>F1:</strong> Toggle debug panel</li>
            </ul>
        </div>
    </div>

    <!-- THREE.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // 全局变量
        let scene, renderer, camera, orbitController;
        let debugLog = [];
        let debugPanelVisible = true;
        
        // 日志函数
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}`;
            debugLog.push(logEntry);
            
            // 限制日志数量
            if (debugLog.length > 100) {
                debugLog.shift();
            }
            
            // 更新显示
            const logElement = document.getElementById('debug-log');
            if (logElement) {
                logElement.textContent = debugLog.join('\n');
                logElement.scrollTop = logElement.scrollHeight;
            }
            
            // 同时输出到控制台
            console.log(logEntry);
        }
        
        // OrbitController 类（简化版）
        class OrbitController {
            constructor(camera, target = { x: 0, y: 0, z: 0 }) {
                this.camera = camera;
                this.target = { ...target };
                this.enabled = true;
                
                // 控制参数
                this.rotateSpeed = 1.0;
                this.zoomSpeed = 1.0;
                this.panSpeed = 1.0;
                this.minDistance = 1;
                this.maxDistance = 100;
                this.minPolarAngle = 0;
                this.maxPolarAngle = Math.PI;
                
                // 内部状态
                this.spherical = this.calculateSpherical();
                this.isRotating = false;
                this.isPanning = false;
                this.lastPointer = { x: 0, y: 0 };
                this.pointers = [];
                
                this.bindEvents();
                log('📷 OrbitController initialized');
            }
            
            calculateSpherical() {
                const position = this.camera.position;
                const dx = position.x - this.target.x;
                const dy = position.y - this.target.y;
                const dz = position.z - this.target.z;
                
                return {
                    radius: Math.sqrt(dx * dx + dy * dy + dz * dz),
                    theta: Math.atan2(dx, dz),
                    phi: Math.acos(Math.max(-1, Math.min(1, dy / Math.sqrt(dx * dx + dy * dy + dz * dz))))
                };
            }
            
            bindEvents() {
                const canvas = document.getElementById('canvas');
                
                canvas.addEventListener('pointerdown', this.onPointerDown.bind(this));
                canvas.addEventListener('pointermove', this.onPointerMove.bind(this));
                canvas.addEventListener('pointerup', this.onPointerUp.bind(this));
                canvas.addEventListener('wheel', this.onWheel.bind(this));
                canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                
                log('✅ OrbitController events bound');
            }
            
            onPointerDown(event) {
                if (!this.enabled) return;
                
                this.pointers.push(event);
                
                if (this.pointers.length === 1) {
                    this.lastPointer = { x: event.clientX, y: event.clientY };
                    
                    if (event.button === 0) {
                        this.isRotating = true;
                    } else if (event.button === 2) {
                        this.isPanning = true;
                    }
                }
                
                event.target.setPointerCapture(event.pointerId);
            }
            
            onPointerMove(event) {
                if (!this.enabled) return;
                
                const pointerIndex = this.pointers.findIndex(p => p.pointerId === event.pointerId);
                if (pointerIndex !== -1) {
                    this.pointers[pointerIndex] = event;
                }
                
                if (this.pointers.length === 1) {
                    const deltaX = event.clientX - this.lastPointer.x;
                    const deltaY = event.clientY - this.lastPointer.y;
                    
                    if (this.isRotating) {
                        this.rotate(deltaX, deltaY);
                    } else if (this.isPanning) {
                        this.pan(deltaX, deltaY);
                    }
                    
                    this.lastPointer = { x: event.clientX, y: event.clientY };
                }
            }
            
            onPointerUp(event) {
                const pointerIndex = this.pointers.findIndex(p => p.pointerId === event.pointerId);
                if (pointerIndex !== -1) {
                    this.pointers.splice(pointerIndex, 1);
                }
                
                if (this.pointers.length === 0) {
                    this.isRotating = false;
                    this.isPanning = false;
                }
                
                event.target.releasePointerCapture(event.pointerId);
            }
            
            onWheel(event) {
                if (!this.enabled) return;
                
                event.preventDefault();
                
                const delta = event.deltaY > 0 ? 1.1 : 0.9;
                this.zoom(delta);
            }
            
            rotate(deltaX, deltaY) {
                const canvas = document.getElementById('canvas');
                const rotateLeft = 2 * Math.PI * deltaX / canvas.clientWidth * this.rotateSpeed;
                const rotateUp = 2 * Math.PI * deltaY / canvas.clientHeight * this.rotateSpeed;
                
                this.spherical.theta -= rotateLeft;
                this.spherical.phi += rotateUp;
                
                this.spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this.spherical.phi));
                
                this.updateCameraPosition();
            }
            
            pan(deltaX, deltaY) {
                const canvas = document.getElementById('canvas');
                
                const right = {
                    x: Math.cos(this.spherical.theta + Math.PI / 2),
                    y: 0,
                    z: Math.sin(this.spherical.theta + Math.PI / 2)
                };
                
                const up = {
                    x: -Math.sin(this.spherical.theta) * Math.cos(this.spherical.phi),
                    y: Math.sin(this.spherical.phi),
                    z: -Math.cos(this.spherical.theta) * Math.cos(this.spherical.phi)
                };
                
                const panX = (deltaX / canvas.clientWidth) * this.spherical.radius * this.panSpeed;
                const panY = (deltaY / canvas.clientHeight) * this.spherical.radius * this.panSpeed;
                
                this.target.x += right.x * panX + up.x * panY;
                this.target.y += right.y * panX + up.y * panY;
                this.target.z += right.z * panX + up.z * panY;
                
                this.updateCameraPosition();
            }
            
            zoom(factor) {
                this.spherical.radius *= factor;
                this.spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.spherical.radius));
                
                this.updateCameraPosition();
            }
            
            updateCameraPosition() {
                const x = this.target.x + this.spherical.radius * Math.sin(this.spherical.phi) * Math.sin(this.spherical.theta);
                const y = this.target.y + this.spherical.radius * Math.cos(this.spherical.phi);
                const z = this.target.z + this.spherical.radius * Math.sin(this.spherical.phi) * Math.cos(this.spherical.theta);
                
                this.camera.position.set(x, y, z);
                this.camera.lookAt(this.target.x, this.target.y, this.target.z);
            }
            
            setEnabled(enabled) {
                this.enabled = enabled;
                log(`📷 OrbitController ${enabled ? 'enabled' : 'disabled'}`);
            }
            
            getStatus() {
                return {
                    enabled: this.enabled,
                    target: this.target,
                    spherical: this.spherical,
                    isRotating: this.isRotating,
                    isPanning: this.isPanning,
                    rotateSpeed: this.rotateSpeed,
                    zoomSpeed: this.zoomSpeed,
                    panSpeed: this.panSpeed
                };
            }
        }
        
        // 初始化函数
        function init() {
            log('🚀 Initializing QAQ Engine Camera Debug');
            
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            
            // 创建渲染器
            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // 添加光照
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // 添加测试对象
            createTestObjects();
            
            // 创建轨道控制器
            orbitController = new OrbitController(camera, { x: 0, y: 0, z: 0 });
            
            // 绑定键盘事件
            document.addEventListener('keydown', onKeyDown);
            
            // 窗口大小调整
            window.addEventListener('resize', onWindowResize);
            
            // 开始渲染循环
            animate();
            
            // 更新调试信息
            updateDebugInfo();
            
            log('✅ Initialization complete');
        }
        
        function createTestObjects() {
            // 创建地面
            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // 创建一些测试立方体
            for (let i = 0; i < 5; i++) {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshLambertMaterial({ 
                    color: new THREE.Color().setHSL(i / 5, 0.7, 0.5) 
                });
                const cube = new THREE.Mesh(geometry, material);
                cube.position.set((i - 2) * 3, 0.5, 0);
                cube.castShadow = true;
                scene.add(cube);
            }
            
            log('📦 Test objects created');
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // 渲染场景
            renderer.render(scene, camera);
            
            // 定期更新调试信息
            if (Math.random() < 0.01) { // 大约每100帧更新一次
                updateDebugInfo();
            }
        }
        
        function updateDebugInfo() {
            // 更新相机信息
            const cameraInfo = document.getElementById('camera-info');
            if (cameraInfo) {
                cameraInfo.innerHTML = `
                    Position: (${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)})<br>
                    FOV: ${camera.fov}°<br>
                    Near: ${camera.near}, Far: ${camera.far}
                `;
            }
            
            // 更新轨道控制器信息
            const orbitInfo = document.getElementById('orbit-info');
            if (orbitInfo && orbitController) {
                const status = orbitController.getStatus();
                orbitInfo.innerHTML = `
                    Enabled: ${status.enabled ? '✅' : '❌'}<br>
                    Target: (${status.target.x.toFixed(2)}, ${status.target.y.toFixed(2)}, ${status.target.z.toFixed(2)})<br>
                    Radius: ${status.spherical.radius.toFixed(2)}<br>
                    Rotating: ${status.isRotating ? '🔄' : '⏸️'}
                `;
            }
            
            // 更新引擎信息
            const engineInfo = document.getElementById('engine-info');
            if (engineInfo) {
                engineInfo.innerHTML = `
                    Renderer: THREE.js WebGL<br>
                    Objects: ${scene.children.length}<br>
                    Memory: ${renderer.info.memory.geometries} geometries, ${renderer.info.memory.textures} textures
                `;
            }
        }
        
        // 测试函数
        function testCameraPosition() {
            log('🧪 Testing camera position changes...');
            
            const positions = [
                { x: 0, y: -200, z: -30 },
                { x: 10, y: 50, z: -20 },
                { x: -15, y: 25, z: 15 },
                { x: 0, y: 5, z: 10 } // 恢复原始位置
            ];
            
            let index = 0;
            const testInterval = setInterval(() => {
                if (index >= positions.length) {
                    clearInterval(testInterval);
                    log('✅ Camera position test completed');
                    return;
                }
                
                const pos = positions[index];
                camera.position.set(pos.x, pos.y, pos.z);
                camera.lookAt(0, 0, 0);
                
                // 更新轨道控制器
                if (orbitController) {
                    orbitController.spherical = orbitController.calculateSpherical();
                }
                
                log(`📷 Camera moved to: (${pos.x}, ${pos.y}, ${pos.z})`);
                index++;
            }, 1500);
        }
        
        function testCameraActivation() {
            log('🧪 Testing camera activation...');
            log('📷 Current camera is active (no multi-camera system in this debug)');
            log('✅ Camera activation test completed');
        }
        
        function toggleOrbitControls() {
            if (orbitController) {
                const status = orbitController.getStatus();
                orbitController.setEnabled(!status.enabled);
                updateDebugInfo();
            }
        }
        
        function configureOrbitController() {
            if (orbitController) {
                log('🔧 Configuring orbit controller...');
                orbitController.rotateSpeed = 0.5;
                orbitController.zoomSpeed = 0.8;
                orbitController.panSpeed = 0.3;
                orbitController.minDistance = 5;
                orbitController.maxDistance = 50;
                log('✅ Orbit controller configured');
            }
        }
        
        function resetCameraView() {
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
            
            if (orbitController) {
                orbitController.target = { x: 0, y: 0, z: 0 };
                orbitController.spherical = orbitController.calculateSpherical();
            }
            
            log('🔄 Camera view reset');
        }
        
        function checkEngineStatus() {
            log('🔍 Checking engine status...');
            log(`📊 Scene objects: ${scene.children.length}`);
            log(`📷 Camera position: (${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)})`);
            log(`🎮 Orbit controller: ${orbitController ? 'Active' : 'Inactive'}`);
            updateDebugInfo();
        }
        
        function clearLog() {
            debugLog = [];
            const logElement = document.getElementById('debug-log');
            if (logElement) {
                logElement.textContent = '';
            }
        }
        
        function onKeyDown(event) {
            if (event.code === 'F1') {
                event.preventDefault();
                const panel = document.getElementById('debug-panel');
                debugPanelVisible = !debugPanelVisible;
                panel.style.display = debugPanelVisible ? 'block' : 'none';
                log(`🐛 Debug panel ${debugPanelVisible ? 'shown' : 'hidden'}`);
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            log('📐 Window resized');
        }
        
        // 启动应用
        window.addEventListener('load', init);
    </script>
</body>
</html>
